<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Taschenspielplatz</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #2a5a1e;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

#viewport {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  overflow: hidden;
}

canvas {
  position: absolute;
  top: 0; left: 0;
  image-rendering: auto;
}

/* UI Layer */
#ui {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 100;
}

#app-title {
  position: absolute;
  top: 8px; left: 0; right: 0;
  text-align: center;
  font-size: 13px;
  font-weight: 600;
  letter-spacing: 0.5px;
  color: rgba(255,255,255,0.5);
  pointer-events: none;
}

/* Safe area insets for notched devices */
@supports (padding-top: env(safe-area-inset-top)) {
  #app-title { top: calc(8px + env(safe-area-inset-top)); }
}
</style>
</head>
<body>

<div id="viewport">
  <canvas id="world-canvas"></canvas>
</div>

<div id="ui">
  <div id="app-title">Taschenspielplatz</div>
</div>

<script>
(function() {
  'use strict';

  // ─── Constants ─────────────────────────────────────────────
  var TILE_SIZE = 128;
  var STORAGE_KEY = 'taschenspielplatz_v4';
  var RENDER_BUFFER = 2;

  // ─── Asset Loading ─────────────────────────────────────────
  var ASSET_NAMES = ['ground', 'road', 'road_curved', 'road_crossroad', 'road_tjunction', 'car'];
  var assets = {};
  var assetsLoaded = 0;

  function loadAssets(callback) {
    ASSET_NAMES.forEach(function(name) {
      var img = new Image();
      img.onload = function() {
        assets[name] = img;
        assetsLoaded++;
        if (assetsLoaded === ASSET_NAMES.length) callback();
      };
      img.onerror = function() {
        console.error('Failed to load asset: ' + name);
        assetsLoaded++;
        if (assetsLoaded === ASSET_NAMES.length) callback();
      };
      img.src = 'assets/' + name + '.png';
    });
  }

  // ─── World Data Model ──────────────────────────────────────
  // The world is a pure data object. The renderer reads it, the controls mutate it.

  function createEmptyWorld(w, h) {
    var tiles = [];
    for (var y = 0; y < h; y++) {
      for (var x = 0; x < w; x++) {
        tiles.push({ x: x, y: y, type: 'ground' });
      }
    }
    return {
      width: w,
      height: h,
      tiles: tiles,
      interactives: [],
      vehicles: [],
      activeVehicleId: null
    };
  }

  function getTile(world, x, y) {
    if (x < 0 || x >= world.width || y < 0 || y >= world.height) return null;
    return world.tiles[y * world.width + x];
  }

  function setTile(world, x, y, type, rotation) {
    if (x < 0 || x >= world.width || y < 0 || y >= world.height) return;
    var tile = world.tiles[y * world.width + x];
    tile.type = type;
    tile.rotation = rotation || 0;
  }

  function isRoad(world, x, y) {
    var t = getTile(world, x, y);
    if (!t) return false;
    return t.type === 'road' || t.type === 'road_curved' || t.type === 'road_crossroad' || t.type === 'road_tjunction';
  }

  // ─── Default World Layout ──────────────────────────────────

  function buildDefaultWorld() {
    var world = createEmptyWorld(20, 20);

    function road(x, y, rot) { setTile(world, x, y, 'road', rot || 0); }
    function curve(x, y, rot) { setTile(world, x, y, 'road_curved', rot || 0); }
    function cross(x, y) { setTile(world, x, y, 'road_crossroad', 0); }
    function tjunc(x, y, rot) { setTile(world, x, y, 'road_tjunction', rot || 0); }

    // ── Main horizontal avenue (row 3) ──
    curve(2, 3, 0);     // South + East
    road(3, 3, 90); road(4, 3, 90); road(5, 3, 90); road(6, 3, 90);
    cross(7, 3);
    road(8, 3, 90); road(9, 3, 90); road(10, 3, 90);
    tjunc(11, 3, 180);  // E + S + W (open North)
    road(12, 3, 90); road(13, 3, 90); road(14, 3, 90); road(15, 3, 90);
    tjunc(16, 3, 180);  // E + S + W (open North)
    curve(17, 3, 90);   // West + South

    // ── Main horizontal avenue (row 10) ──
    curve(2, 10, 270);  // East + North
    road(3, 10, 90); road(4, 10, 90); road(5, 10, 90); road(6, 10, 90);
    cross(7, 10);
    road(8, 10, 90); road(9, 10, 90); road(10, 10, 90);
    cross(11, 10);
    road(12, 10, 90); road(13, 10, 90); road(14, 10, 90); road(15, 10, 90);
    tjunc(16, 10, 0);   // N + E + W (open South)
    curve(17, 10, 180); // North + West

    // ── Main horizontal avenue (row 16) ──
    curve(4, 16, 270);    // South + East
    road(5, 16, 90); road(6, 16, 90);
    tjunc(7, 16, 0);    // N + E + W (open South)
    road(8, 16, 90); road(9, 16, 90); road(10, 16, 90);
    cross(11, 16);      // true 4-way crossroad
    road(12, 16, 90); road(13, 16, 90);
    curve(14, 16, 180); // North + West

    // ── Vertical street: col 2, rows 3→10 ──
    road(2, 4, 0); road(2, 5, 0); road(2, 6, 0); road(2, 7, 0);
    road(2, 8, 0); road(2, 9, 0);

    // ── Vertical street: col 7, rows 3→16 ──
    road(7, 4, 0); road(7, 5, 0); road(7, 6, 0); road(7, 7, 0);
    road(7, 8, 0); road(7, 9, 0);
    road(7, 11, 0); road(7, 12, 0); road(7, 13, 0); road(7, 14, 0);
    road(7, 15, 0);

    // ── Vertical street: col 11, rows 3→16 ──
    road(11, 4, 0); road(11, 5, 0); road(11, 6, 0); road(11, 7, 0);
    road(11, 8, 0); road(11, 9, 0);
    road(11, 11, 0); road(11, 12, 0); road(11, 13, 0); road(11, 14, 0);
    road(11, 15, 0);

    // ── Vertical street: col 16, rows 3→10 ──
    road(16, 4, 0); road(16, 5, 0); road(16, 6, 0); road(16, 7, 0);
    road(16, 8, 0); road(16, 9, 0);

    // ── Vertical street: col 17, rows 3→10 ──
    road(17, 4, 0); road(17, 5, 0); road(17, 6, 0); road(17, 7, 0);
    road(17, 8, 0); road(17, 9, 0);

    // ── Small loop: top-left residential area ──
    curve(4, 1, 0);     // South + East
    road(5, 1, 90); road(6, 1, 90);
    curve(7, 1, 90);    // West + South
    road(4, 2, 0);
    road(7, 2, 0);
    setTile(world, 4, 3, 'road_tjunction', 0);  // N + E + W (open South)

    // ── Small spur: dead-end street going north from row 3 ──
    road(14, 1, 0); road(14, 2, 0);
    setTile(world, 14, 3, 'road_tjunction', 0);  // N + E + W (open South)

    // ── Small loop: bottom-right ──
    tjunc(14, 13, 90);  // N + E + S (open West)
    road(15, 13, 90); road(16, 13, 90);
    curve(17, 13, 90);  // West + South
    road(14, 14, 0);
    road(17, 14, 0);
    curve(14, 15, 270); // East + North
    road(15, 15, 90); road(16, 15, 90);
    curve(17, 15, 180); // North + West
    road(14, 11, 0); road(14, 12, 0);
    setTile(world, 14, 10, 'road_tjunction', 180);  // E + S + W (open North)

    // ── Dead-end street south from crossroad at (11,16) ──
    road(11, 17, 0); road(11, 18, 0); road(11, 19, 0);

    // ── Short connector: col 4, row 10→16 ──
    road(4, 13, 0); road(4, 14, 0); road(4, 15, 0);
    setTile(world, 4, 10, 'road_tjunction', 180);  // E + S + W (open North)
    road(4, 11, 0); road(4, 12, 0);

    // ── Place 5 vehicles ──
    world.vehicles = [
      { id: 'car1', type: 'car', x: 5,  y: 3,  angle: 90,  speed: 1.0, hue: 0 },
      { id: 'car2', type: 'car', x: 9,  y: 3,  angle: 90,  speed: 0.6, hue: 200 },
      { id: 'car3', type: 'car', x: 7,  y: 6,  angle: 0,   speed: 0.8, hue: 100 },
      { id: 'car4', type: 'car', x: 4,  y: 12, angle: 180,  speed: 0.4, hue: 40 },
      { id: 'car5', type: 'car', x: 16, y: 7,  angle: 0,   speed: 0.7, hue: 300 }
    ];
    world.activeVehicleId = 'car1';

    return world;
  }

  // ─── State ─────────────────────────────────────────────────
  var world = null;
  var canvas, ctx;
  var viewportEl;
  var panX = 0, panY = 0, scale = 1;
  var MIN_SCALE = 0.3, MAX_SCALE = 3;

  // Per-vehicle animation state, keyed by vehicle id
  var vehicleAnim = {};

  function initVehicleAnim(v) {
    vehicleAnim[v.id] = {
      pixelX: (v.x + 0.5) * TILE_SIZE,
      pixelY: (v.y + 0.5) * TILE_SIZE,
      angle: v.angle || 0,
      path: [],
      moving: false,
      pathIndex: 0,
      progress: 0,
      tilt: 0,
      squash: 1,
      prevAngle: v.angle || 0,
      justStarted: 0
    };
  }

  // Camera follow
  var cameraFollowing = false;

  // Animation
  var animFrameId = null;
  var lastTime = 0;

  // Active vehicle pulse timer (for glow effect)
  var pulseTime = 0;

  // Hue-rotated car image cache
  var hueCache = {};

  function getHueRotatedCar(hue) {
    if (hue === 0) return assets.car;
    if (hueCache[hue]) return hueCache[hue];

    // Manual pixel-level hue rotation (works on iOS Safari and Firefox)
    var w = assets.car.width;
    var h = assets.car.height;
    var oc = document.createElement('canvas');
    oc.width = w;
    oc.height = h;
    var octx = oc.getContext('2d');
    octx.drawImage(assets.car, 0, 0);

    var imageData = octx.getImageData(0, 0, w, h);
    var d = imageData.data;
    var shift = ((hue % 360) + 360) % 360;

    for (var i = 0; i < d.length; i += 4) {
      if (d[i + 3] === 0) continue; // skip transparent

      var r = d[i] / 255, g = d[i + 1] / 255, b = d[i + 2] / 255;
      var max = Math.max(r, g, b), min = Math.min(r, g, b);
      var delta = max - min;
      var hVal, s, l = (max + min) / 2;

      if (delta === 0) continue; // grey pixel, no hue to shift

      s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);

      if (max === r) hVal = ((g - b) / delta + (g < b ? 6 : 0)) * 60;
      else if (max === g) hVal = ((b - r) / delta + 2) * 60;
      else hVal = ((r - g) / delta + 4) * 60;

      hVal = (hVal + shift) % 360;

      // HSL to RGB
      var c = (1 - Math.abs(2 * l - 1)) * s;
      var x = c * (1 - Math.abs((hVal / 60) % 2 - 1));
      var m = l - c / 2;
      var r1, g1, b1;

      if (hVal < 60)       { r1 = c; g1 = x; b1 = 0; }
      else if (hVal < 120) { r1 = x; g1 = c; b1 = 0; }
      else if (hVal < 180) { r1 = 0; g1 = c; b1 = x; }
      else if (hVal < 240) { r1 = 0; g1 = x; b1 = c; }
      else if (hVal < 300) { r1 = x; g1 = 0; b1 = c; }
      else                 { r1 = c; g1 = 0; b1 = x; }

      d[i]     = Math.round((r1 + m) * 255);
      d[i + 1] = Math.round((g1 + m) * 255);
      d[i + 2] = Math.round((b1 + m) * 255);
    }

    octx.putImageData(imageData, 0, 0);
    hueCache[hue] = oc;
    return oc;
  }

  // ─── Canvas Renderer ───────────────────────────────────────

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function worldToScreen(wx, wy) {
    return {
      x: wx * scale + panX,
      y: wy * scale + panY
    };
  }

  function screenToWorld(sx, sy) {
    return {
      x: (sx - panX) / scale,
      y: (sy - panY) / scale
    };
  }

  function screenToTile(sx, sy) {
    var w = screenToWorld(sx, sy);
    return {
      x: Math.floor(w.x / TILE_SIZE),
      y: Math.floor(w.y / TILE_SIZE)
    };
  }

  function render() {
    if (!ctx || !world) return;

    var cw = canvas.width;
    var ch = canvas.height;
    ctx.clearRect(0, 0, cw, ch);

    // Fill background with dark green
    ctx.fillStyle = '#2a5a1e';
    ctx.fillRect(0, 0, cw, ch);

    // Calculate visible tile range
    var topLeft = screenToWorld(0, 0);
    var bottomRight = screenToWorld(cw, ch);

    var startCol = Math.floor(topLeft.x / TILE_SIZE) - RENDER_BUFFER;
    var startRow = Math.floor(topLeft.y / TILE_SIZE) - RENDER_BUFFER;
    var endCol = Math.ceil(bottomRight.x / TILE_SIZE) + RENDER_BUFFER;
    var endRow = Math.ceil(bottomRight.y / TILE_SIZE) + RENDER_BUFFER;

    startCol = Math.max(0, startCol);
    startRow = Math.max(0, startRow);
    endCol = Math.min(world.width - 1, endCol);
    endRow = Math.min(world.height - 1, endRow);

    var tileSizeScaled = TILE_SIZE * scale;

    // Draw tiles
    for (var row = startRow; row <= endRow; row++) {
      for (var col = startCol; col <= endCol; col++) {
        var tile = getTile(world, col, row);
        if (!tile) continue;

        var sx = col * TILE_SIZE * scale + panX;
        var sy = row * TILE_SIZE * scale + panY;

        var assetName = tile.type || 'ground';
        var img = assets[assetName];
        if (!img) continue;

        var rotation = tile.rotation || 0;

        if (rotation === 0) {
          ctx.drawImage(img, sx, sy, tileSizeScaled, tileSizeScaled);
        } else {
          ctx.save();
          ctx.translate(sx + tileSizeScaled / 2, sy + tileSizeScaled / 2);
          ctx.rotate(rotation * Math.PI / 180);
          ctx.drawImage(img, -tileSizeScaled / 2, -tileSizeScaled / 2, tileSizeScaled, tileSizeScaled);
          ctx.restore();
        }
      }
    }

    // Draw vehicles (inactive first, active last so it's on top)
    for (var vi = 0; vi < world.vehicles.length; vi++) {
      var v = world.vehicles[vi];
      if (v.id === world.activeVehicleId) continue;
      drawVehicle(v, false);
    }
    // Draw active vehicle last (on top)
    var activeV = getActiveVehicle();
    if (activeV) drawVehicle(activeV, true);
  }

  function drawVehicle(v, isActive) {
    var anim = vehicleAnim[v.id];
    if (!anim || !assets.car) return;

    var carImg = getHueRotatedCar(v.hue);

    var sx = anim.pixelX * scale + panX;
    var sy = anim.pixelY * scale + panY;
    var carW = TILE_SIZE * 0.55 * scale;
    var carH = TILE_SIZE * 0.75 * scale;
    var rotRad = (anim.angle - 90) * Math.PI / 180;
    var tiltRad = anim.tilt * Math.PI / 180;

    // ── Active vehicle glow (pulsing) ──
    if (isActive) {
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(rotRad);

      var pulse = 0.35 + 0.2 * Math.sin(pulseTime * 3);
      var glowRadius = carH * 0.7;
      ctx.shadowColor = 'rgba(255, 255, 100, ' + pulse + ')';
      ctx.shadowBlur = Math.max(12, 20 * scale);
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Draw a transparent rect to trigger the shadow
      ctx.fillStyle = 'rgba(255, 255, 100, 0.01)';
      ctx.fillRect(-carW / 2 - 2, -carH / 2 - 2, carW + 4, carH + 4);
      ctx.restore();
    }

    // ── Vehicle body with drop shadow ──
    ctx.save();
    ctx.translate(sx, sy);
    ctx.rotate(rotRad);

    // Tilt: skew perpendicular to direction of travel
    ctx.transform(1, 0, Math.tan(tiltRad), anim.squash, 0, 0);

    // Shadow
    ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
    ctx.shadowBlur = Math.max(4, 6 * scale);
    ctx.shadowOffsetX = 3 * scale;
    ctx.shadowOffsetY = 4 * scale;

    ctx.drawImage(carImg, -carW / 2, -carH / 2, carW, carH);
    ctx.restore();
  }

  // ─── Vehicle helpers ───────────────────────────────────────

  function getActiveVehicle() {
    if (!world) return null;
    for (var i = 0; i < world.vehicles.length; i++) {
      if (world.vehicles[i].id === world.activeVehicleId) return world.vehicles[i];
    }
    return null;
  }

  function getVehicleAt(tx, ty) {
    // Check if any vehicle occupies the given tile
    for (var i = 0; i < world.vehicles.length; i++) {
      var v = world.vehicles[i];
      if (v.x === tx && v.y === ty) return v;
    }
    return null;
  }

  function getVehicleNearScreenPos(clientX, clientY) {
    // Check if a tap is close enough to any vehicle (within 0.6 tiles)
    var wp = screenToWorld(clientX, clientY);
    var bestV = null;
    var bestDist = Infinity;
    var threshold = TILE_SIZE * 0.7; // generous tap target

    for (var i = 0; i < world.vehicles.length; i++) {
      var v = world.vehicles[i];
      var anim = vehicleAnim[v.id];
      if (!anim) continue;

      var dx = wp.x - anim.pixelX;
      var dy = wp.y - anim.pixelY;
      var dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < threshold && dist < bestDist) {
        bestDist = dist;
        bestV = v;
      }
    }
    return bestV;
  }

  // ─── Pathfinding (BFS on road grid) ────────────────────────

  function curveConnects(rotation, dx, dy) {
    var connections = {
      0:   [[0, 1], [1, 0]],
      90:  [[-1, 0], [0, 1]],
      180: [[0, -1], [-1, 0]],
      270: [[1, 0], [0, -1]]
    };
    var conns = connections[rotation] || connections[0];
    for (var i = 0; i < conns.length; i++) {
      if (conns[i][0] === dx && conns[i][1] === dy) return true;
    }
    return false;
  }

  function straightConnects(rotation, dx, dy) {
    if (rotation === 0 || rotation === 180) {
      return (dx === 0 && (dy === -1 || dy === 1));
    } else {
      return (dy === 0 && (dx === -1 || dx === 1));
    }
  }

  // Check if a T-junction connects in a given direction
  // T-junction at rotation 0: connects N (0,-1), E (1,0), W (-1,0) — open South
  //   90: connects N (0,-1), E (1,0), S (0,1) — open West
  //   180: connects E (1,0), S (0,1), W (-1,0) — open North
  //   270: connects N (0,-1), S (0,1), W (-1,0) — open East
  function tjunctionConnects(rotation, dx, dy) {
    var connections = {
      0:   [[0, -1], [1, 0], [-1, 0]],
      90:  [[0, -1], [1, 0], [0, 1]],
      180: [[1, 0], [0, 1], [-1, 0]],
      270: [[0, -1], [0, 1], [-1, 0]]
    };
    var conns = connections[rotation] || connections[0];
    for (var i = 0; i < conns.length; i++) {
      if (conns[i][0] === dx && conns[i][1] === dy) return true;
    }
    return false;
  }

  function tileConnectsInDirection(world, x, y, dx, dy) {
    var tile = getTile(world, x, y);
    if (!tile) return false;
    if (tile.type === 'road_crossroad') return true;
    if (tile.type === 'road_tjunction') return tjunctionConnects(tile.rotation || 0, dx, dy);
    if (tile.type === 'road') return straightConnects(tile.rotation || 0, dx, dy);
    if (tile.type === 'road_curved') return curveConnects(tile.rotation || 0, dx, dy);
    return false;
  }

  function getConnectedRoads(world, x, y) {
    var neighbors = [];
    var dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]];
    for (var i = 0; i < dirs.length; i++) {
      var dx = dirs[i][0], dy = dirs[i][1];
      var nx = x + dx, ny = y + dy;
      if (tileConnectsInDirection(world, x, y, dx, dy) &&
          tileConnectsInDirection(world, nx, ny, -dx, -dy)) {
        neighbors.push({ x: nx, y: ny });
      }
    }
    return neighbors;
  }

  function bfsPath(world, startX, startY, endX, endY) {
    if (startX === endX && startY === endY) return [{ x: startX, y: startY }];
    if (!isRoad(world, startX, startY) || !isRoad(world, endX, endY)) return null;

    var queue = [{ x: startX, y: startY }];
    var visited = {};
    var parent = {};
    var key = function(x, y) { return x + ',' + y; };

    visited[key(startX, startY)] = true;

    while (queue.length > 0) {
      var current = queue.shift();

      if (current.x === endX && current.y === endY) {
        var path = [];
        var node = current;
        while (node) {
          path.unshift({ x: node.x, y: node.y });
          node = parent[key(node.x, node.y)];
        }
        return path;
      }

      var neighbors = getConnectedRoads(world, current.x, current.y);
      for (var i = 0; i < neighbors.length; i++) {
        var n = neighbors[i];
        var nk = key(n.x, n.y);
        if (!visited[nk]) {
          visited[nk] = true;
          parent[nk] = current;
          queue.push(n);
        }
      }
    }

    return null;
  }

  function findNearestRoad(world, tx, ty) {
    var best = null;
    var bestDist = Infinity;
    for (var i = 0; i < world.tiles.length; i++) {
      var t = world.tiles[i];
      if (t.type === 'road' || t.type === 'road_curved' || t.type === 'road_crossroad' || t.type === 'road_tjunction') {
        var dx = t.x - tx;
        var dy = t.y - ty;
        var dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          best = t;
        }
      }
    }
    return best;
  }

  // ─── Vehicle Movement ──────────────────────────────────────

  function startVehiclePath(v, path) {
    if (!path || path.length < 2) return;
    var anim = vehicleAnim[v.id];
    if (!anim) return;

    anim.path = path;
    anim.pathIndex = 0;
    anim.progress = 0;
    anim.moving = true;
    anim.justStarted = 0.25;
    cameraFollowing = true;
  }

  function stopVehicle(v) {
    var anim = vehicleAnim[v.id];
    if (!anim) return;

    anim.moving = false;
    anim.path = [];
    anim.pathIndex = 0;
    anim.progress = 0;
    anim.squash = 0.92;
  }

  function updateVehicle(v, dt) {
    var anim = vehicleAnim[v.id];
    if (!anim || !anim.moving || anim.path.length < 2) return;

    var speed = 3 * (v.speed || 1);

    anim.progress += dt * speed;

    while (anim.progress >= 1 && anim.pathIndex < anim.path.length - 2) {
      anim.pathIndex++;
      anim.progress -= 1;
    }

    if (anim.pathIndex >= anim.path.length - 1) {
      var last = anim.path[anim.path.length - 1];
      anim.pixelX = (last.x + 0.5) * TILE_SIZE;
      anim.pixelY = (last.y + 0.5) * TILE_SIZE;
      v.x = last.x;
      v.y = last.y;
      stopVehicle(v);
      return;
    }

    // Interpolate position
    var from = anim.path[anim.pathIndex];
    var to = anim.path[anim.pathIndex + 1];
    var t = Math.min(anim.progress, 1);
    var st = t * t * (3 - 2 * t); // smoothstep

    anim.pixelX = ((from.x + 0.5) + (to.x - from.x) * st) * TILE_SIZE;
    anim.pixelY = ((from.y + 0.5) + (to.y - from.y) * st) * TILE_SIZE;

    // Update angle
    var dx = to.x - from.x;
    var dy = to.y - from.y;
    if (dx !== 0 || dy !== 0) {
      var targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
      anim.prevAngle = anim.angle;
      anim.angle = lerpAngle(anim.angle, targetAngle, Math.min(1, dt * 10));
    }

    // Tilt: lean into turns
    var angularVel = ((anim.angle - anim.prevAngle + 540) % 360) - 180;
    var targetTilt = Math.max(-3.5, Math.min(3.5, angularVel * 0.8));
    anim.tilt += (targetTilt - anim.tilt) * Math.min(1, dt * 8);

    // Squash: compress on start
    if (anim.justStarted > 0) {
      anim.justStarted -= dt;
      var sp = Math.max(0, anim.justStarted / 0.25);
      anim.squash = 1 - 0.08 * Math.sin(sp * Math.PI);
    } else {
      anim.squash += (1 - anim.squash) * Math.min(1, dt * 6);
    }

    v.x = from.x;
    v.y = from.y;
    v.angle = anim.angle;
  }

  function lerpAngle(a, b, t) {
    var diff = ((b - a + 540) % 360) - 180;
    return a + diff * t;
  }

  // ─── Touch / Pointer Handling ──────────────────────────────
  var pointers = {};
  var touchStartTime = 0;
  var touchMoved = false;
  var lastPanX = 0, lastPanY = 0;
  var lastPinchDist = 0;
  var lastPinchCX = 0, lastPinchCY = 0;
  var isPanning = false;
  var tapStartX = 0, tapStartY = 0;

  function getPointerArray() {
    var arr = [];
    for (var id in pointers) arr.push(pointers[id]);
    return arr;
  }

  function getPinchData(arr) {
    var dx = arr[1].x - arr[0].x;
    var dy = arr[1].y - arr[0].y;
    return {
      dist: Math.sqrt(dx * dx + dy * dy),
      cx: (arr[0].x + arr[1].x) / 2,
      cy: (arr[0].y + arr[1].y) / 2
    };
  }

  function onPointerDown(e) {
    if (e.target.closest('.ui-btn')) return;
    e.preventDefault();

    pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    var pArr = getPointerArray();

    if (pArr.length === 1) {
      touchStartTime = Date.now();
      touchMoved = false;
      lastPanX = e.clientX;
      lastPanY = e.clientY;
      tapStartX = e.clientX;
      tapStartY = e.clientY;
      isPanning = false;
    } else if (pArr.length >= 2) {
      var pd = getPinchData(pArr);
      lastPinchDist = pd.dist;
      lastPinchCX = pd.cx;
      lastPinchCY = pd.cy;
      isPanning = true;
    }
  }

  function onPointerMove(e) {
    if (!pointers[e.pointerId]) return;
    e.preventDefault();

    pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    var pArr = getPointerArray();

    if (pArr.length === 1) {
      var dx = e.clientX - lastPanX;
      var dy = e.clientY - lastPanY;

      if (!isPanning && (Math.abs(dx) > 8 || Math.abs(dy) > 8)) {
        isPanning = true;
        touchMoved = true;
        cameraFollowing = false;
      }

      if (isPanning) {
        panX += dx;
        panY += dy;
        lastPanX = e.clientX;
        lastPanY = e.clientY;
      }
    } else if (pArr.length >= 2) {
      var pd = getPinchData(pArr);
      cameraFollowing = false;

      var zoomRatio = pd.dist / lastPinchDist;
      var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomRatio));

      var dCx = pd.cx - lastPinchCX;
      var dCy = pd.cy - lastPinchCY;

      panX = panX + dCx - (lastPinchCX - panX) * (newScale / scale - 1);
      panY = panY + dCy - (lastPinchCY - panY) * (newScale / scale - 1);
      scale = newScale;

      lastPinchDist = pd.dist;
      lastPinchCX = pd.cx;
      lastPinchCY = pd.cy;

      touchMoved = true;
    }
  }

  function onPointerUp(e) {
    if (!pointers[e.pointerId]) return;
    e.preventDefault();

    delete pointers[e.pointerId];

    var elapsed = Date.now() - touchStartTime;
    if (!touchMoved && elapsed < 400) {
      handleTap(tapStartX, tapStartY);
    }

    var pArr = getPointerArray();
    if (pArr.length >= 2) {
      var pd = getPinchData(pArr);
      lastPinchDist = pd.dist;
      lastPinchCX = pd.cx;
      lastPinchCY = pd.cy;
    }
  }

  function onPointerCancel(e) {
    delete pointers[e.pointerId];
  }

  function onWheel(e) {
    e.preventDefault();
    cameraFollowing = false;
    var rect = canvas.getBoundingClientRect();
    var mx = e.clientX - rect.left;
    var my = e.clientY - rect.top;

    var zoomFactor = e.deltaY < 0 ? 1.08 : 0.92;
    var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));

    panX = mx - (mx - panX) * (newScale / scale);
    panY = my - (my - panY) * (newScale / scale);
    scale = newScale;
  }

  // ─── Tap Handler ───────────────────────────────────────────
  // Priority: Vehicle tap > World tap

  function handleTap(clientX, clientY) {
    // 1. Check if tapped on a vehicle
    var tappedVehicle = getVehicleNearScreenPos(clientX, clientY);
    if (tappedVehicle) {
      switchToVehicle(tappedVehicle);
      return;
    }

    // 2. Navigate active vehicle to tapped location
    var tile = screenToTile(clientX, clientY);
    navigateActiveVehicleTo(tile.x, tile.y);
  }

  function switchToVehicle(v) {
    if (world.activeVehicleId === v.id) return; // already active

    // Stop the currently active vehicle if it's moving
    var current = getActiveVehicle();
    if (current) {
      var currentAnim = vehicleAnim[current.id];
      if (currentAnim && currentAnim.moving) {
        // Snap to current position on path
        if (currentAnim.pathIndex < currentAnim.path.length) {
          var snapTile = currentAnim.path[currentAnim.pathIndex];
          current.x = snapTile.x;
          current.y = snapTile.y;
        }
        stopVehicle(current);
      }
    }

    world.activeVehicleId = v.id;

    // Center camera on newly active vehicle
    var anim = vehicleAnim[v.id];
    if (anim) {
      cameraFollowing = true;
    }

    saveState();
  }

  function navigateActiveVehicleTo(tx, ty) {
    var v = getActiveVehicle();
    if (!v) return;

    var anim = vehicleAnim[v.id];
    var startX = v.x;
    var startY = v.y;

    // If vehicle is currently moving, use current position
    if (anim && anim.moving && anim.path.length > 0 && anim.pathIndex < anim.path.length) {
      startX = anim.path[anim.pathIndex].x;
      startY = anim.path[anim.pathIndex].y;
      v.x = startX;
      v.y = startY;
    }

    var targetX = tx, targetY = ty;

    // If target is not a road, find nearest road
    if (!isRoad(world, tx, ty)) {
      var nearest = findNearestRoad(world, tx, ty);
      if (nearest) {
        targetX = nearest.x;
        targetY = nearest.y;
      } else {
        return;
      }
    }

    var path = bfsPath(world, startX, startY, targetX, targetY);
    if (path && path.length >= 2) {
      stopVehicle(v);
      startVehiclePath(v, path);
    }
  }

  // ─── Persistence ───────────────────────────────────────────

  function saveState() {
    try {
      var vehicleStates = world.vehicles.map(function(v) {
        return {
          id: v.id, x: v.x, y: v.y, angle: v.angle,
          speed: v.speed, hue: v.hue
        };
      });

      var state = {
        vehicles: vehicleStates,
        activeVehicleId: world.activeVehicleId,
        pan: { x: panX, y: panY },
        scale: scale
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch(e) {}
  }

  function loadState() {
    try {
      var raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      var state = JSON.parse(raw);

      if (state.vehicles && state.vehicles.length === world.vehicles.length) {
        for (var i = 0; i < state.vehicles.length; i++) {
          var saved = state.vehicles[i];
          var v = world.vehicles[i];
          if (saved.id === v.id) {
            v.x = saved.x;
            v.y = saved.y;
            v.angle = saved.angle || 0;
          }
        }
      }

      if (state.activeVehicleId) {
        world.activeVehicleId = state.activeVehicleId;
      }

      if (state.pan) {
        panX = state.pan.x;
        panY = state.pan.y;
      }
      if (state.scale) {
        scale = state.scale;
      }

      return true;
    } catch(e) {
      return false;
    }
  }

  // ─── Game Loop ─────────────────────────────────────────────

  function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    var dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;

    pulseTime += dt;

    // Update all vehicles
    for (var i = 0; i < world.vehicles.length; i++) {
      var v = world.vehicles[i];
      var anim = vehicleAnim[v.id];
      if (!anim) continue;

      updateVehicle(v, dt);

      // Spring back squash/tilt when stopped
      if (!anim.moving) {
        anim.squash += (1 - anim.squash) * Math.min(1, dt * 8);
        anim.tilt += (0 - anim.tilt) * Math.min(1, dt * 6);
      }
    }

    // Camera follow active vehicle
    if (cameraFollowing) {
      var activeV = getActiveVehicle();
      if (activeV) {
        var activeAnim = vehicleAnim[activeV.id];
        if (activeAnim) {
          var targetPanX = canvas.width / 2 - activeAnim.pixelX * scale;
          var targetPanY = canvas.height / 2 - activeAnim.pixelY * scale;
          var ease = Math.min(1, dt * 2.5);
          panX += (targetPanX - panX) * ease;
          panY += (targetPanY - panY) * ease;

          if (!activeAnim.moving) {
            var dPan = Math.abs(targetPanX - panX) + Math.abs(targetPanY - panY);
            if (dPan < 1) cameraFollowing = false;
          }
        }
      }
    }

    render();

    animFrameId = requestAnimationFrame(gameLoop);
  }

  // ─── Initialization ────────────────────────────────────────

  function init() {
    canvas = document.getElementById('world-canvas');
    ctx = canvas.getContext('2d');
    viewportEl = document.getElementById('viewport');

    resizeCanvas();

    // Build world
    world = buildDefaultWorld();

    // Initialize animation state for all vehicles
    for (var i = 0; i < world.vehicles.length; i++) {
      initVehicleAnim(world.vehicles[i]);
    }

    // Load saved state (or use defaults)
    var loaded = loadState();

    // Re-init anim positions from possibly-loaded vehicle positions
    for (var j = 0; j < world.vehicles.length; j++) {
      var v = world.vehicles[j];
      var anim = vehicleAnim[v.id];
      if (anim) {
        anim.pixelX = (v.x + 0.5) * TILE_SIZE;
        anim.pixelY = (v.y + 0.5) * TILE_SIZE;
        anim.angle = v.angle || 0;
        anim.prevAngle = v.angle || 0;
      }
    }

    if (!loaded) {
      // Center view on the active vehicle
      var activeV = getActiveVehicle();
      if (activeV) {
        var carCenterX = (activeV.x + 0.5) * TILE_SIZE;
        var carCenterY = (activeV.y + 0.5) * TILE_SIZE;

        var vw = window.innerWidth;
        var vh = window.innerHeight;
        scale = Math.min(vw / (10 * TILE_SIZE), vh / (14 * TILE_SIZE), 1.2);

        panX = vw / 2 - carCenterX * scale;
        panY = vh / 2 - carCenterY * scale;
      }
    }

    // Event listeners
    viewportEl.addEventListener('pointerdown', onPointerDown, { passive: false });
    viewportEl.addEventListener('pointermove', onPointerMove, { passive: false });
    viewportEl.addEventListener('pointerup', onPointerUp, { passive: false });
    viewportEl.addEventListener('pointercancel', onPointerCancel);
    viewportEl.addEventListener('wheel', onWheel, { passive: false });

    document.addEventListener('touchstart', function(e) {
      if (!e.target.closest('.ui-btn')) e.preventDefault();
    }, { passive: false });
    document.addEventListener('touchmove', function(e) {
      e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturestart', function(e) { e.preventDefault(); });

    window.addEventListener('resize', resizeCanvas);

    setInterval(saveState, 5000);

    document.addEventListener('visibilitychange', function() {
      if (document.hidden) saveState();
    });

    lastTime = 0;
    animFrameId = requestAnimationFrame(gameLoop);
  }

  // ─── Boot ──────────────────────────────────────────────────
  loadAssets(init);

})();
</script>
</body>
</html>
