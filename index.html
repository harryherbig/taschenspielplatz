<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Taschenspielplatz</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: #1a3a0a;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

/* ---- Start Screen ---- */
#start-screen {
  position: fixed; inset: 0;
  display: flex; flex-direction: column;
  align-items: center;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-y;
  background: linear-gradient(135deg, #2d5016 0%, #1a3a0a 50%, #0f2205 100%);
  z-index: 200;
  transition: opacity 0.4s ease;
  padding: 40px 20px 40px;
}
#start-screen.hidden { opacity: 0; pointer-events: none; }

#start-welcome {
  display: flex; flex-direction: column;
  align-items: center;
  max-width: 320px;
  text-align: center;
}

#start-logo {
  width: 120px; height: 120px;
  border-radius: 24px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  margin-bottom: 16px;
}

#start-tagline {
  font-size: 18px;
  font-weight: 700;
  color: rgba(255,255,255,0.9);
  letter-spacing: 0.3px;
  margin-bottom: 8px;
}

#start-subtitle {
  font-size: 14px;
  font-weight: 400;
  color: rgba(255,255,255,0.5);
  margin-bottom: 24px;
  line-height: 1.5;
}

#start-philosophy {
  display: flex; flex-direction: column;
  gap: 12px;
  width: 100%;
}

.philosophy-item {
  font-size: 13px;
  color: rgba(255,255,255,0.5);
  text-align: left;
  padding: 10px 14px;
  border-radius: 10px;
  background: rgba(255,255,255,0.04);
  line-height: 1.5;
}

.philosophy-label {
  color: rgba(255,255,255,0.85);
  font-weight: 600;
}

#start-divider {
  width: 60px; height: 2px;
  background: rgba(255,255,255,0.15);
  border-radius: 1px;
  margin: 28px 0 20px;
}

#start-choose {
  font-size: 14px;
  font-weight: 600;
  color: rgba(255,255,255,0.45);
  letter-spacing: 0.5px;
  text-transform: uppercase;
  margin-bottom: 20px;
}

.world-card {
  width: 260px;
  cursor: pointer;
  border-radius: 16px;
  overflow: hidden;
  background: rgba(255,255,255,0.08);
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.world-card:active {
  transform: scale(0.96);
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
}

.world-card-thumb {
  width: 100%;
  aspect-ratio: 4/3;
  background: #3a7a20;
  display: flex; align-items: center; justify-content: center;
  position: relative;
  overflow: hidden;
}
.world-card-thumb canvas {
  width: 100%; height: 100%;
  object-fit: cover;
}

.world-card-name {
  padding: 14px;
  text-align: center;
  font-size: 16px;
  font-weight: 600;
  color: rgba(255,255,255,0.9);
}

/* ---- Game Screen ---- */
#game-screen {
  position: fixed; inset: 0;
  display: none;
  overflow: hidden;
  background: #2a5a1e;
}
#game-screen.active { display: block; }

#game-canvas {
  position: absolute; top: 0; left: 0;
}

/* Night overlay — only darkens the canvas behind, vehicles stay bright via z-order trick:
   we render vehicles AFTER the overlay in the canvas draw order, so they stay bright.
   Actually we use a CSS overlay that covers the world but we render vehicles on top.
   Simpler: overlay with mix-blend-mode that darkens background but we draw vehicles bright.
   Simplest: just darken the entire canvas via CSS filter and brighten vehicles in draw code.
   Going with CSS overlay approach: overlay sits between canvas and UI. */
#night-overlay {
  position: absolute; inset: 0;
  background: rgba(10, 10, 40, 0.55);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.8s ease;
  z-index: 5;
  mix-blend-mode: multiply;
}
#night-overlay.active { opacity: 1; }

/* UI overlay */
#game-ui {
  position: fixed; inset: 0;
  pointer-events: none;
  z-index: 100;
}

#app-title-small {
  position: absolute;
  top: 8px; left: 0; right: 0;
  text-align: center;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
  color: rgba(255,255,255,0.25);
  pointer-events: none;
}

.ui-btn {
  pointer-events: auto;
  width: 52px; height: 52px;
  border: none;
  border-radius: 14px;
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: white;
  font-size: 22px;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
  transition: background 0.15s;
}
.ui-btn:active { background: rgba(255,255,255,0.25); }

#btn-back {
  position: absolute;
  top: 12px; left: 12px;
}
#btn-daynight {
  position: absolute;
  top: 12px; right: 12px;
}

@supports (padding-top: env(safe-area-inset-top)) {
  #start-screen { padding-top: calc(40px + env(safe-area-inset-top)); padding-bottom: calc(40px + env(safe-area-inset-bottom)); }
  #app-title-small { top: calc(8px + env(safe-area-inset-top)); }
  #btn-back { top: calc(12px + env(safe-area-inset-top)); left: calc(12px + env(safe-area-inset-left)); }
  #btn-daynight { top: calc(12px + env(safe-area-inset-top)); right: calc(12px + env(safe-area-inset-right)); }
}
</style>
</head>
<body>

<!-- Start Screen -->
<div id="start-screen">
  <div id="start-welcome">
    <img id="start-logo" src="assets/app_logo.png" alt="Taschenspielplatz">
    <div id="start-tagline">Kein Spiel. Ein Spielbrett.</div>
    <div id="start-subtitle">Ein digitales Spielbrett für kleine Hände. Die Geschichte erzählt dein Kind selbst.</div>
    <div id="start-philosophy">
      <div class="philosophy-item"><span class="philosophy-label">Keine Punkte.</span> Keine Sterne, keine Level, keine Regeln. Die App will nichts vom Kind.</div>
      <div class="philosophy-item"><span class="philosophy-label">Kein Ton.</span> Perfekt für Auto, Restaurant und Wartezimmer. Die Motorengeräusche macht dein Kind selbst.</div>
      <div class="philosophy-item"><span class="philosophy-label">Freies Spiel.</span> Tippe auf ein Fahrzeug, ziehe es mit dem Finger durch die Stadt. Das war's.</div>
    </div>
  </div>
  <div id="start-divider"></div>
  <div id="start-choose">Wähle eine Welt:</div>
  <div id="world-list"></div>
</div>

<!-- Game Screen -->
<div id="game-screen">
  <canvas id="game-canvas"></canvas>
  <div id="night-overlay"></div>
  <div id="game-ui">
    <div id="app-title-small">Taschenspielplatz</div>
    <button class="ui-btn" id="btn-back" aria-label="Zurück">&#x2190;</button>
    <button class="ui-btn" id="btn-daynight" aria-label="Tag/Nacht">&#x2600;</button>
  </div>
</div>

<script>
'use strict';

// ============================================================
// CONFIG
// ============================================================

const STORAGE_VERSION = 'v6';
const MIN_SCALE = 0.25;
const MAX_SCALE = 3;
const WORLD_W = 2400;
const WORLD_H = 2400;

// Reference size: all positions/speeds are authored as fractions of this
const REF_SIZE = 8192;

// Vehicle sprites: square, tightly cropped, hood pointing UP
const CAR_SCALE_FACTOR = 0.065;  // base vehicle size in world = worldW * this

// ============================================================
// ASSET PACKS — each pack bundles a world with its vehicles
// ============================================================

const ASSET_PACKS = [
  {
    id: 'city',
    name: 'Vorstadt',
    worldImage: 'assets/packs/city/world.png',
    unlocked: true,
    vehicles: [
      { id: 'v-auto',           sprite: 'vehicle_normal',       sizeMul: 1.0, speedF: 0.202, startFX: 0.40, startFY: 0.40, glow: [255, 160, 30] },
      { id: 'v-feuerwehr',      sprite: 'vehicle_fire_truck',   sizeMul: 1.7, speedF: 0.158, startFX: 0.55, startFY: 0.42, glow: [60, 120, 255] },
      { id: 'v-feuerwehr-car',  sprite: 'vehicle_fire_car',     sizeMul: 1.2, speedF: 0.188, startFX: 0.48, startFY: 0.48, glow: [60, 120, 255] },
      { id: 'v-feuerwehr-med',  sprite: 'vehicle_fire_medium',  sizeMul: 1.4, speedF: 0.172, startFX: 0.52, startFY: 0.38, glow: [60, 120, 255] },
      { id: 'v-feuerwehr-ven',  sprite: 'vehicle_fire_venus',   sizeMul: 1.3, speedF: 0.178, startFX: 0.38, startFY: 0.52, glow: [60, 120, 255] },
      { id: 'v-krankenwagen',   sprite: 'vehicle_ambulance',    sizeMul: 1.4, speedF: 0.168, startFX: 0.45, startFY: 0.55, glow: [60, 120, 255] },
      { id: 'v-adac',           sprite: 'vehicle_adac',         sizeMul: 1.2, speedF: 0.144, startFX: 0.35, startFY: 0.58, glow: [255, 160, 30], canTow: true },
    ],
  },
  // Future packs:
  // { id: 'construction', name: 'Baustelle', worldImage: 'assets/packs/construction/world.png', unlocked: false, vehicles: [...] },
  // { id: 'farm', name: 'Bauernhof', worldImage: 'assets/packs/farm/world.png', unlocked: false, vehicles: [...] },
];

// Actual world pixel size — set when a world loads
var worldW = REF_SIZE;
var worldH = REF_SIZE;

// ============================================================
// PLACEHOLDER WORLD
// ============================================================

function generatePlaceholderWorld(w, h) {
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');

  // Grass
  ctx.fillStyle = '#4a8c2a';
  ctx.fillRect(0, 0, w, h);
  for (let i = 0; i < 300; i++) {
    ctx.fillStyle = 'rgba(' + (50 + (Math.random()*30|0)) + ',' + (120 + (Math.random()*40|0)) + ',' + (20 + (Math.random()*20|0)) + ',0.35)';
    ctx.fillRect(Math.random()*w, Math.random()*h, 20+Math.random()*80, 20+Math.random()*80);
  }

  // Roads
  const roadW = 100;
  const hRoads = [400, 1200, 2000];
  const vRoads = [600, 1200, 1800];

  function drawRoad(x, y, rw, rh) {
    ctx.fillStyle = '#666';
    ctx.fillRect(x, y, rw, rh);
  }

  for (const ry of hRoads) {
    drawRoad(0, ry - roadW/2, w, roadW);
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 3;
    ctx.setLineDash([20, 20]);
    ctx.beginPath(); ctx.moveTo(0, ry); ctx.lineTo(w, ry); ctx.stroke();
    ctx.setLineDash([]);
  }
  for (const rx of vRoads) {
    drawRoad(rx - roadW/2, 0, roadW, h);
    ctx.strokeStyle = '#999';
    ctx.lineWidth = 3;
    ctx.setLineDash([20, 20]);
    ctx.beginPath(); ctx.moveTo(rx, 0); ctx.lineTo(rx, h); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Buildings
  const buildings = [
    {x:150,y:150,w:180,h:140,color:'#c0392b'},{x:800,y:150,w:200,h:160,color:'#2980b9'},
    {x:1400,y:150,w:160,h:130,color:'#8e44ad'},{x:2000,y:150,w:170,h:150,color:'#d35400'},
    {x:150,y:600,w:200,h:180,color:'#27ae60'},{x:800,y:550,w:240,h:200,color:'#f39c12'},
    {x:1400,y:600,w:180,h:160,color:'#1abc9c'},{x:2000,y:580,w:200,h:180,color:'#e74c3c'},
    {x:150,y:1400,w:220,h:180,color:'#3498db'},{x:800,y:1450,w:180,h:160,color:'#e67e22'},
    {x:1400,y:1400,w:200,h:190,color:'#9b59b6'},{x:2000,y:1430,w:190,h:170,color:'#16a085'},
    {x:300,y:2100,w:160,h:140,color:'#c0392b'},{x:900,y:2120,w:180,h:160,color:'#2c3e50'},
    {x:1500,y:2080,w:200,h:180,color:'#d35400'},
  ];
  for (const b of buildings) {
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(b.x+6, b.y+6, b.w, b.h);
    ctx.fillStyle = b.color;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(b.x, b.y, b.w, 12);
    ctx.fillStyle = 'rgba(255,255,200,0.6)';
    for (let wx = b.x+20; wx < b.x+b.w-20; wx += 35) {
      for (let wy = b.y+30; wy < b.y+b.h-20; wy += 35) {
        ctx.fillRect(wx, wy, 20, 20);
      }
    }
  }

  // Trees
  for (let i = 0; i < 50; i++) {
    const tx = 50+Math.random()*(w-100);
    const ty = 50+Math.random()*(h-100);
    if (hRoads.some(function(ry){return Math.abs(ty-ry)<70;})) continue;
    if (vRoads.some(function(rx){return Math.abs(tx-rx)<70;})) continue;
    if (buildings.some(function(b){return tx>b.x-10&&tx<b.x+b.w+10&&ty>b.y-10&&ty<b.y+b.h+10;})) continue;
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath(); ctx.ellipse(tx+4, ty+4, 22, 18, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'hsl('+(110+Math.random()*30)+','+(50+Math.random()*20)+'%,'+(28+Math.random()*15)+'%)';
    ctx.beginPath(); ctx.ellipse(tx, ty, 18+Math.random()*10, 14+Math.random()*8, 0, 0, Math.PI*2); ctx.fill();
  }

  // Roundabout center
  ctx.fillStyle = '#666';
  ctx.beginPath(); ctx.arc(1200,1200,120,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#4a8c2a';
  ctx.beginPath(); ctx.arc(1200,1200,60,0,Math.PI*2); ctx.fill();

  // Pond
  ctx.fillStyle = '#3498db';
  ctx.beginPath(); ctx.ellipse(1900,1050,90,60,0.2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.beginPath(); ctx.ellipse(1880,1035,40,20,0.3,0,Math.PI*2); ctx.fill();

  return c;
}

// ============================================================
// CAR SPRITE FALLBACK
// ============================================================

function generateCarSprite() {
  const c = document.createElement('canvas');
  c.width = 60; c.height = 90;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#e74c3c';
  ctx.beginPath(); ctx.roundRect(8, 10, 44, 70, 8); ctx.fill();
  ctx.fillStyle = 'rgba(150,200,255,0.7)';
  ctx.fillRect(14, 18, 32, 18);
  ctx.fillStyle = 'rgba(150,200,255,0.5)';
  ctx.fillRect(14, 58, 32, 14);
  ctx.fillStyle = '#222';
  ctx.fillRect(4,20,8,16); ctx.fillRect(48,20,8,16);
  ctx.fillRect(4,54,8,16); ctx.fillRect(48,54,8,16);
  return c;
}

// ============================================================
// HUE ROTATION (via canvas filter — no getImageData needed)
// ============================================================

// ============================================================
// STATE
// ============================================================

var currentScreen = 'start';

var gameState = {
  panX: 0, panY: 0, scale: 1,
  isNight: false,
  activeVehicleId: null,
  cameraFollowing: false,
  pulseTime: 0,
  vehicles: [],
};

// ============================================================
// ASSETS
// ============================================================

var currentPack = null;     // active pack reference
var packSprites = {};       // sprite name → canvas (per-pack)
var worldImage = null;

function getSpritePath(pack, spriteName) {
  return 'assets/packs/' + pack.id + '/' + spriteName + '.png';
}

function loadPackSprites(pack) {
  var spriteNames = [];
  for (var i = 0; i < pack.vehicles.length; i++) {
    var name = pack.vehicles[i].sprite;
    if (spriteNames.indexOf(name) === -1) spriteNames.push(name);
  }

  packSprites = {};

  var promises = spriteNames.map(function(name) {
    return new Promise(function(resolve) {
      var img = new Image();
      img.onload = function() {
        var c = document.createElement('canvas');
        c.width = img.width; c.height = img.height;
        c.getContext('2d').drawImage(img, 0, 0);
        packSprites[name] = c;
        resolve();
      };
      img.onerror = function() {
        packSprites[name] = generateCarSprite();
        resolve();
      };
      img.src = getSpritePath(pack, name);
    });
  });
  return Promise.all(promises);
}

function loadWorldImage(pack) {
  return new Promise(function(resolve) {
    var img = new Image();
    img.onload = function() {
      worldImage = img;
      worldW = img.width;
      worldH = img.height;
      resolve();
    };
    img.onerror = function() {
      worldImage = generatePlaceholderWorld(WORLD_W, WORLD_H);
      worldW = WORLD_W;
      worldH = WORLD_H;
      resolve();
    };
    img.src = pack.worldImage;
  });
}

// ============================================================
// TIRE TRACKS
// ============================================================

var TRACK_FADE_TIME = 16;       // seconds until fully faded
var TRACK_SAMPLE_DIST = 0.008;  // min distance between samples (fraction of worldW)
var tireTrackSegments = [];     // array of { x, y, angle, width, time }

function sampleTireTrack(v, now) {
  var cs = getCarSize(v.sizeMul);
  var minDist = TRACK_SAMPLE_DIST * worldW;
  var last = v._lastTrackX;

  // Only sample if moved enough since last sample
  if (last != null) {
    var ddx = v.x - v._lastTrackX;
    var ddy = v.y - v._lastTrackY;
    if (ddx * ddx + ddy * ddy < minDist * minDist) return;
  }

  tireTrackSegments.push({
    x: v.x, y: v.y,
    angle: v.angle,
    width: cs.w * 0.35,
    time: now,
    vid: v.id,
  });

  v._lastTrackX = v.x;
  v._lastTrackY = v.y;
}

function pruneTireTracks(now) {
  while (tireTrackSegments.length > 0 && now - tireTrackSegments[0].time > TRACK_FADE_TIME) {
    tireTrackSegments.shift();
  }
}

function drawTireTracks(now) {
  if (tireTrackSegments.length < 2) return;
  var panX = gameState.panX, panY = gameState.panY, scale = gameState.scale;

  for (var i = 1; i < tireTrackSegments.length; i++) {
    var prev = tireTrackSegments[i - 1];
    var cur = tireTrackSegments[i];

    // Don't connect segments from different vehicles
    if (prev.vid !== cur.vid) continue;

    var age = now - cur.time;
    var alpha = Math.max(0, 1 - age / TRACK_FADE_TIME) * 0.3;
    if (alpha <= 0) continue;

    // Two tire lines offset perpendicular to heading
    var lineW = Math.max(1, 8 * scale);
    var trackInset = lineW / scale * 1.5;

    var rad = (cur.angle + 90) * Math.PI / 180;
    var perpX = Math.cos(rad);
    var perpY = Math.sin(rad);
    var offset = (cur.width * 0.45 - trackInset) * scale;
    var prevRad = (prev.angle + 90) * Math.PI / 180;
    var prevPerpX = Math.cos(prevRad);
    var prevPerpY = Math.sin(prevRad);
    var prevOffset = (prev.width * 0.45 - trackInset) * scale;

    var px = prev.x * scale + panX;
    var py = prev.y * scale + panY;
    var cx = cur.x * scale + panX;
    var cy = cur.y * scale + panY;

    ctx.strokeStyle = 'rgba(40, 35, 30, ' + alpha + ')';
    ctx.lineWidth = lineW;
    ctx.lineCap = 'round';

    // Left tire
    ctx.beginPath();
    ctx.moveTo(px + prevPerpX * prevOffset, py + prevPerpY * prevOffset);
    ctx.lineTo(cx + perpX * offset, cy + perpY * offset);
    ctx.stroke();

    // Right tire
    ctx.beginPath();
    ctx.moveTo(px - prevPerpX * prevOffset, py - prevPerpY * prevOffset);
    ctx.lineTo(cx - perpX * offset, cy - perpY * offset);
    ctx.stroke();
  }
}

// ============================================================
// VEHICLES
// ============================================================

function createVehicle(def) {
  return {
    id: def.id, sprite: def.sprite, sizeMul: def.sizeMul || 1,
    glow: def.glow,
    maxSpeed: def.speedF * worldW,
    x: def.startFX * worldW,
    y: def.startFY * worldH,
    angle: 0,         // heading in degrees (0 = right, 90 = down)
    vx: 0, vy: 0,     // current velocity (for SmoothDamp)
    targetX: null, targetY: null,
    dragging: false,
    _lastTrackX: null, _lastTrackY: null,
    aiTargetX: null, aiTargetY: null,  // autonomous roaming target
    aiBrakeUntil: 0,                   // timestamp until which the vehicle is braking
    canTow: def.canTow || false,
    towingId: null,    // id of vehicle being towed (only for canTow vehicles)
    towedById: null,   // id of vehicle towing this one
  };
}

function initVehicles(pack) {
  gameState.vehicles = pack.vehicles.map(createVehicle);
  gameState.activeVehicleId = null;
  tireTrackSegments = [];
}

// ============================================================
// PERSISTENCE
// ============================================================

function getPackStorageKey(pack) {
  return 'taschenspielplatz_' + STORAGE_VERSION + '_' + pack.id;
}

function savePackState(pack) {
  if (!pack) return;
  try {
    var data = {
      packId: pack.id,
      vehicleCount: pack.vehicles.length,
      vehicles: gameState.vehicles.map(function(v) {
        return { id: v.id, x: v.x, y: v.y, angle: v.angle };
      }),
      activeVehicleId: gameState.activeVehicleId,
      pan: { x: gameState.panX, y: gameState.panY },
      scale: gameState.scale,
      isNight: gameState.isNight,
    };
    localStorage.setItem(getPackStorageKey(pack), JSON.stringify(data));
  } catch(e) {}
}

function loadPackState(pack) {
  try {
    var raw = localStorage.getItem(getPackStorageKey(pack));
    if (!raw) return false;
    var data = JSON.parse(raw);
    if (data.packId !== pack.id) return false;
    if (data.vehicleCount !== pack.vehicles.length) return false;

    if (data.vehicles) {
      for (var i = 0; i < data.vehicles.length; i++) {
        var sv = data.vehicles[i];
        var v = gameState.vehicles.find(function(vv) { return vv.id === sv.id; });
        if (v) {
          // Only restore if position is within current world bounds
          if (sv.x >= 0 && sv.x <= worldW && sv.y >= 0 && sv.y <= worldH) {
            v.x = sv.x; v.y = sv.y; v.angle = sv.angle || 0;
          }
        }
      }
    }
    if (data.activeVehicleId != null) gameState.activeVehicleId = data.activeVehicleId;
    if (data.pan) { gameState.panX = data.pan.x; gameState.panY = data.pan.y; }
    if (data.scale) gameState.scale = data.scale;
    if (data.isNight != null) gameState.isNight = data.isNight;
    return true;
  } catch(e) { return false; }
}

function migrateV5Storage() {
  var OLD_KEY = 'taschenspielplatz_v5';
  try {
    var raw = localStorage.getItem(OLD_KEY);
    if (!raw) return;
    var newKey = 'taschenspielplatz_' + STORAGE_VERSION + '_city';
    if (localStorage.getItem(newKey)) return;  // already migrated
    var data = JSON.parse(raw);
    data.packId = 'city';
    data.vehicleCount = ASSET_PACKS[0].vehicles.length;
    localStorage.setItem(newKey, JSON.stringify(data));
  } catch(e) {}
}

// ============================================================
// RENDERING
// ============================================================

var canvas = document.getElementById('game-canvas');
var ctx = canvas.getContext('2d');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function lerpAngle(a, b, t) {
  var diff = ((b - a + 540) % 360) - 180;
  return a + diff * t;
}

function getCarSize(sizeMul) {
  // All vehicle sprites are square, tightly cropped
  var carS = worldW * CAR_SCALE_FACTOR * (sizeMul || 1);
  return { w: carS, h: carS };
}

function drawVehicle(v, isActive) {
  var sprite = packSprites[v.sprite];
  if (!sprite) return;
  var panX = gameState.panX, panY = gameState.panY, scale = gameState.scale;

  var sx = v.x * scale + panX;
  var sy = v.y * scale + panY;
  var cs = getCarSize(v.sizeMul);
  var carW = cs.w * scale;
  var carH = cs.h * scale;
  var rotRad = (v.angle + 90) * Math.PI / 180;

  // Soft round shadow beneath the vehicle for better visibility
  ctx.save();
  ctx.translate(sx, sy);
  ctx.rotate(rotRad);
  var shadowRadius = Math.max(carW, carH) * 0.75;
  var grad = ctx.createRadialGradient(0, 0, shadowRadius * 0.15, 0, 0, shadowRadius);
  if (isActive) {
    var pulse = 0.7 + 0.3 * Math.sin(gameState.pulseTime * 3);
    var g = v.glow || [255, 220, 40];
    grad.addColorStop(0, 'rgba(' + g[0] + ',' + g[1] + ',' + g[2] + ',' + pulse + ')');
    grad.addColorStop(0.4, 'rgba(' + g[0] + ',' + g[1] + ',' + g[2] + ',' + (pulse * 0.6) + ')');
    grad.addColorStop(0.75, 'rgba(' + g[0] + ',' + g[1] + ',' + g[2] + ',' + (pulse * 0.25) + ')');
    grad.addColorStop(1, 'rgba(' + g[0] + ',' + g[1] + ',' + g[2] + ',0)');
  } else {
    grad.addColorStop(0, 'rgba(0, 0, 0, 0.55)');
    grad.addColorStop(0.5, 'rgba(0, 0, 0, 0.25)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
  }
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, shadowRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // Draw the vehicle sprite
  ctx.save();
  ctx.translate(sx, sy);
  ctx.rotate(rotRad);
  ctx.drawImage(sprite, -carW/2, -carH/2, carW, carH);
  ctx.restore();
}

// Offscreen canvas for night overlay (reused each frame)
var nightCanvas = document.createElement('canvas');
var nightCtx = nightCanvas.getContext('2d');

function drawNightOverlay(activeV) {
  var cw = canvas.width, ch = canvas.height;
  var scale = gameState.scale;
  var panX = gameState.panX, panY = gameState.panY;

  // Resize offscreen canvas if needed
  if (nightCanvas.width !== cw || nightCanvas.height !== ch) {
    nightCanvas.width = cw;
    nightCanvas.height = ch;
  }

  // Fill with darkness
  nightCtx.clearRect(0, 0, cw, ch);
  nightCtx.fillStyle = 'rgba(8, 8, 35, 0.6)';
  nightCtx.fillRect(0, 0, cw, ch);

  // Erase light holes from the darkness
  nightCtx.globalCompositeOperation = 'destination-out';

  for (var i = 0; i < gameState.vehicles.length; i++) {
    var v = gameState.vehicles[i];
    var vsx = v.x * scale + panX;
    var vsy = v.y * scale + panY;
    var cs = getCarSize(v.sizeMul);
    var vSize = Math.max(cs.w, cs.h) * scale;
    var isActive = (v.id === gameState.activeVehicleId);

    // Ambient glow around every vehicle
    var ambR = isActive ? vSize * 0.7 : vSize * 0.35;
    var ambA = isActive ? 1.0 : 0.35;
    var ambGrad = nightCtx.createRadialGradient(vsx, vsy, 0, vsx, vsy, ambR);
    ambGrad.addColorStop(0, 'rgba(255,255,255,' + ambA + ')');
    ambGrad.addColorStop(0.4, 'rgba(255,255,255,' + (ambA * 0.6) + ')');
    ambGrad.addColorStop(1, 'rgba(255,255,255,0)');
    nightCtx.fillStyle = ambGrad;
    nightCtx.beginPath();
    nightCtx.arc(vsx, vsy, ambR, 0, Math.PI * 2);
    nightCtx.fill();

    // Headlight cone for active vehicle
    if (isActive) {
      var rotRad = (v.angle + 90) * Math.PI / 180;
      var dirX = Math.cos(rotRad - Math.PI / 2);
      var dirY = Math.sin(rotRad - Math.PI / 2);

      var coneLen = vSize * 1.5;
      var coneWidth = coneLen * 0.5;

      // Center of the cone beam (offset forward from vehicle)
      var beamCX = vsx + dirX * coneLen * 0.55;
      var beamCY = vsy + dirY * coneLen * 0.55;

      // Draw as a rotated soft ellipse
      nightCtx.save();
      nightCtx.translate(beamCX, beamCY);
      nightCtx.rotate(rotRad - Math.PI / 2);
      // Ellipse: long along the beam direction, narrower sideways
      var eGrad = nightCtx.createRadialGradient(0, 0, 0, 0, 0, 1);
      eGrad.addColorStop(0, 'rgba(255,255,255,1)');
      eGrad.addColorStop(0.3, 'rgba(255,255,255,0.85)');
      eGrad.addColorStop(0.7, 'rgba(255,255,255,0.3)');
      eGrad.addColorStop(1, 'rgba(255,255,255,0)');
      nightCtx.fillStyle = eGrad;
      nightCtx.scale(coneWidth, coneLen);
      nightCtx.beginPath();
      nightCtx.arc(0, 0, 1, 0, Math.PI * 2);
      nightCtx.fill();
      nightCtx.restore();
    }
  }

  nightCtx.globalCompositeOperation = 'source-over';

  // Composite the darkness layer onto the main canvas
  ctx.drawImage(nightCanvas, 0, 0);

  // Subtle warm tint in the headlight area (on the main canvas)
  if (activeV) {
    var asx = activeV.x * scale + panX;
    var asy = activeV.y * scale + panY;
    var acs = getCarSize(activeV.sizeMul);
    var aSize = Math.max(acs.w, acs.h) * scale;

    var hRotRad = (activeV.angle + 90) * Math.PI / 180;
    var hDirX = Math.cos(hRotRad - Math.PI / 2);
    var hDirY = Math.sin(hRotRad - Math.PI / 2);
    var hBeamCX = asx + hDirX * aSize * 0.7;
    var hBeamCY = asy + hDirY * aSize * 0.7;
    var hR = aSize * 0.8;

    var hGrad = ctx.createRadialGradient(hBeamCX, hBeamCY, 0, hBeamCX, hBeamCY, hR);
    hGrad.addColorStop(0, 'rgba(255, 245, 200, 0.06)');
    hGrad.addColorStop(0.5, 'rgba(255, 245, 200, 0.02)');
    hGrad.addColorStop(1, 'rgba(255, 245, 200, 0)');
    ctx.fillStyle = hGrad;
    ctx.beginPath();
    ctx.arc(hBeamCX, hBeamCY, hR, 0, Math.PI * 2);
    ctx.fill();
  }
}

function render() {
  var panX = gameState.panX, panY = gameState.panY, scale = gameState.scale;
  var cw = canvas.width, ch = canvas.height;

  ctx.clearRect(0, 0, cw, ch);
  ctx.fillStyle = '#4a8c2a';
  ctx.fillRect(0, 0, cw, ch);

  if (worldImage) {
    var imgW = worldW * scale;
    var imgH = worldH * scale;
    ctx.drawImage(worldImage, panX, panY, imgW, imgH);
  }

  // Tire tracks (between world and vehicles)
  pruneTireTracks(gameState.pulseTime);
  drawTireTracks(gameState.pulseTime);

  // Inactive vehicles first
  for (var i = 0; i < gameState.vehicles.length; i++) {
    var v = gameState.vehicles[i];
    if (v.id === gameState.activeVehicleId) continue;
    drawVehicle(v, false);
  }
  // Active vehicle on top
  var activeV = gameState.vehicles.find(function(v) { return v.id === gameState.activeVehicleId; });
  if (activeV) drawVehicle(activeV, true);

  // Tow button overlay
  drawTowButton();

  // Night mode: canvas-based darkness with light cutouts
  if (gameState.isNight) {
    drawNightOverlay(activeV);
  }
}

function drawTowButton() {
  if (!towButtonTarget) return;
  var v = gameState.vehicles.find(function(vv) { return vv.id === towButtonTarget; });
  if (!v) return;

  var panX = gameState.panX, panY = gameState.panY, scale = gameState.scale;
  var sx = v.x * scale + panX;
  var sy = v.y * scale + panY;
  var cs = getCarSize(v.sizeMul);
  var btnRadius = Math.max(cs.w, cs.h) * scale * 0.32;
  btnRadius = Math.max(btnRadius, 20);

  // Frosted glass circle
  ctx.save();
  ctx.filter = 'blur(4px)';
  ctx.beginPath();
  ctx.arc(sx, sy, btnRadius, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
  ctx.fill();
  ctx.filter = 'none';

  // Subtle border
  ctx.beginPath();
  ctx.arc(sx, sy, btnRadius, 0, Math.PI * 2);
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.stroke();

  // Wrench emoji
  ctx.font = Math.round(btnRadius * 0.9) + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('\uD83D\uDD27', sx, sy);
  ctx.restore();
}

// ============================================================
// VEHICLE MOVEMENT — SmoothDamp steering model
// ============================================================

// SmoothDamp: critically-damped spring (like Unity's Mathf.SmoothDamp)
// Returns { val, vel } — new value and new velocity
function smoothDamp(current, target, currentVel, smoothTime, maxSpeed, dt) {
  smoothTime = Math.max(0.0001, smoothTime);
  var omega = 2.0 / smoothTime;
  var x = omega * dt;
  // Padé approximant for exp(-x)
  var exp = 1.0 / (1.0 + x + 0.48 * x * x + 0.235 * x * x * x);
  var delta = current - target;
  var maxDelta = maxSpeed * smoothTime;
  // Clamp
  if (delta > maxDelta) delta = maxDelta;
  else if (delta < -maxDelta) delta = -maxDelta;
  var temp = (currentVel + omega * delta) * dt;
  var newVel = (currentVel - omega * temp) * exp;
  var newVal = (current - delta) + (delta + temp) * exp;
  // Overshoot guard
  if ((target - current > 0) === (newVal > target)) {
    newVal = target;
    newVel = 0;
  }
  return { val: newVal, vel: newVel };
}

// Turn rate: slower when moving fast (like a real vehicle), tighter when slow/stopped
var MAX_TURN_RATE_SLOW = 180;   // deg/sec at very low speed (tight maneuvering)
var MAX_TURN_RATE_FAST = 60;    // deg/sec at full speed (highway feel)
// SmoothDamp time — lower = snappier, higher = floatier
var DRAG_SMOOTH_TIME = 0.015;
var AI_SPEED_FACTOR = 0.18;       // fraction of maxSpeed for roaming
var AI_TURN_RATE = 45;            // deg/sec for AI steering
var AI_BRAKE_CHANCE = 0.008;      // chance per frame to start braking
var AI_BRAKE_DURATION_MIN = 1.0;  // seconds
var AI_BRAKE_DURATION_MAX = 3.0;

function pickAITarget(v) {
  var cs = getCarSize(v.sizeMul);
  var margin = cs.h;
  v.aiTargetX = margin + Math.random() * (worldW - 2 * margin);
  v.aiTargetY = margin + Math.random() * (worldH - 2 * margin);
}

function updateAIRoaming(v, dt) {
  var cs = getCarSize(v.sizeMul);
  var now = gameState.pulseTime;

  // Braking?
  if (v.aiBrakeUntil > now) {
    v.vx *= Math.max(0, 1 - 4 * dt);
    v.vy *= Math.max(0, 1 - 4 * dt);
    // Still sample tire tracks while slowing
    var curVel = Math.sqrt(v.vx * v.vx + v.vy * v.vy);
    if (curVel > v.maxSpeed * 0.02) {
      v.x += v.vx * dt;
      v.y += v.vy * dt;
      sampleTireTrack(v, now);
    }
    return;
  }

  // Random chance to brake
  if (Math.random() < AI_BRAKE_CHANCE) {
    v.aiBrakeUntil = now + AI_BRAKE_DURATION_MIN + Math.random() * (AI_BRAKE_DURATION_MAX - AI_BRAKE_DURATION_MIN);
    return;
  }

  // Pick a new target if none or reached
  if (v.aiTargetX == null || v.aiTargetY == null) {
    pickAITarget(v);
  }
  var dx = v.aiTargetX - v.x;
  var dy = v.aiTargetY - v.y;
  var dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < cs.h * 0.5) {
    pickAITarget(v);
    dx = v.aiTargetX - v.x;
    dy = v.aiTargetY - v.y;
    dist = Math.sqrt(dx * dx + dy * dy);
  }

  // Steer toward target
  var targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
  var angleDiff = ((targetAngle - v.angle + 540) % 360) - 180;
  var maxTurn = AI_TURN_RATE * dt;
  if (angleDiff > maxTurn) angleDiff = maxTurn;
  else if (angleDiff < -maxTurn) angleDiff = -maxTurn;
  v.angle += angleDiff;
  v.angle = ((v.angle % 360) + 360) % 360;

  // Move forward along heading
  var speed = v.maxSpeed * AI_SPEED_FACTOR;
  var headRad = v.angle * Math.PI / 180;
  v.vx = Math.cos(headRad) * speed;
  v.vy = Math.sin(headRad) * speed;
  v.x += v.vx * dt;
  v.y += v.vy * dt;

  // Tire tracks
  sampleTireTrack(v, now);

  // Clamp to world bounds and pick new target if hitting edge
  var halfW = cs.w * 0.4, halfH = cs.h * 0.4;
  var hitEdge = false;
  if (v.x < halfW)          { v.x = halfW;          v.vx = 0; hitEdge = true; }
  if (v.x > worldW - halfW) { v.x = worldW - halfW; v.vx = 0; hitEdge = true; }
  if (v.y < halfH)          { v.y = halfH;          v.vy = 0; hitEdge = true; }
  if (v.y > worldH - halfH) { v.y = worldH - halfH; v.vy = 0; hitEdge = true; }
  if (hitEdge) pickAITarget(v);
}

function updateVehicles(dt) {
  for (var i = 0; i < gameState.vehicles.length; i++) {
    var v = gameState.vehicles[i];

    // Towed vehicles are fully controlled by updateTowing — skip here
    if (v.towedById) continue;

    if (!v.dragging) {
      // Non-active vehicles roam autonomously
      if (v.id === gameState.activeVehicleId) {
        // Active but not being dragged — just brake
        v.vx *= Math.max(0, 1 - 8 * dt);
        v.vy *= Math.max(0, 1 - 8 * dt);
        continue;
      }
      updateAIRoaming(v, dt);
      continue;
    }

    if (v.targetX == null || v.targetY == null) continue;

    var dx = v.targetX - v.x;
    var dy = v.targetY - v.y;
    var dist = Math.sqrt(dx * dx + dy * dy);

    // Dead zone — don't jitter when finger is right on the car
    var cs = getCarSize(v.sizeMul);
    var deadZone = cs.h * 0.1;
    if (dist < deadZone) {
      v.vx *= Math.max(0, 1 - 10 * dt);
      v.vy *= Math.max(0, 1 - 10 * dt);
      continue;
    }

    // 1) STEER: turn rate depends on current speed — fast = wide turns, slow = tight
    var curVel = Math.sqrt(v.vx * v.vx + v.vy * v.vy);
    var speedRatio = Math.min(1, curVel / v.maxSpeed);
    var turnRate = MAX_TURN_RATE_SLOW + (MAX_TURN_RATE_FAST - MAX_TURN_RATE_SLOW) * speedRatio;

    var targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
    var angleDiff = ((targetAngle - v.angle + 540) % 360) - 180; // -180..180
    var maxTurn = turnRate * dt;
    if (angleDiff > maxTurn) angleDiff = maxTurn;
    else if (angleDiff < -maxTurn) angleDiff = -maxTurn;
    v.angle += angleDiff;
    // Normalize
    v.angle = ((v.angle % 360) + 360) % 360;

    // 2) MOVE: only along the vehicle's heading direction (no strafing)
    var speed = v.maxSpeed;
    var approachScale = Math.min(1, dist / (cs.h * 2));
    var curSpeed = speed * (0.3 + 0.7 * approachScale);

    // Project distance onto heading direction — only move forward
    var headRad = v.angle * Math.PI / 180;
    var headX = Math.cos(headRad);
    var headY = Math.sin(headRad);
    var forwardDist = dx * headX + dy * headY; // dot product
    if (forwardDist < 0) {
      // Allow slow reversing for tow trucks, block for others
      forwardDist = v.towingId ? Math.abs(forwardDist) * 0.3 : 0;
    }

    var targetSpeed = Math.min(curSpeed, forwardDist / dt);
    var desiredVx = headX * targetSpeed;
    var desiredVy = headY * targetSpeed;

    // Smooth the speed transition
    var rx = smoothDamp(v.vx, desiredVx, 0, DRAG_SMOOTH_TIME, curSpeed * 3, dt);
    var ry = smoothDamp(v.vy, desiredVy, 0, DRAG_SMOOTH_TIME, curSpeed * 3, dt);
    v.vx = rx.val;
    v.vy = ry.val;
    v.x += v.vx * dt;
    v.y += v.vy * dt;

    // Sample tire track while moving
    if (curVel > v.maxSpeed * 0.05) {
      sampleTireTrack(v, gameState.pulseTime);
    }

    // Clamp to world bounds
    var halfW = cs.w * 0.4, halfH = cs.h * 0.4;
    if (v.x < halfW)          { v.x = halfW;          v.vx = 0; }
    if (v.x > worldW - halfW) { v.x = worldW - halfW; v.vx = 0; }
    if (v.y < halfH)          { v.y = halfH;          v.vy = 0; }
    if (v.y > worldH - halfH) { v.y = worldH - halfH; v.vy = 0; }
  }

  // --- COLLISION SEPARATION ---
  separateVehicles();

  // --- TOWING ---
  updateTowing(dt);
}

function separateVehicles() {
  var vehicles = gameState.vehicles;
  // Run a few iterations to resolve chain collisions
  for (var iter = 0; iter < 3; iter++) {
    for (var i = 0; i < vehicles.length; i++) {
      var a = vehicles[i];
      var csA = getCarSize(a.sizeMul);
      var rA = Math.max(csA.w, csA.h) * 0.45;

      for (var j = i + 1; j < vehicles.length; j++) {
        var b = vehicles[j];

        // Skip collision between tow truck and the vehicle it's towing
        if (a.towingId && a.towingId === b.id) continue;
        if (b.towingId && b.towingId === a.id) continue;

        var csB = getCarSize(b.sizeMul);
        var rB = Math.max(csB.w, csB.h) * 0.45;

        var dx = b.x - a.x;
        var dy = b.y - a.y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var minDist = rA + rB;

        if (dist >= minDist || dist < 0.001) continue;

        // Overlap — push apart
        var overlap = minDist - dist;
        var nx = dx / dist;
        var ny = dy / dist;

        // Dragged vehicle gets less push (20%), other gets 80%
        var aWeight, bWeight;
        if (a.dragging && b.dragging) {
          aWeight = 0.5; bWeight = 0.5;
        } else if (a.dragging) {
          aWeight = 0.2; bWeight = 0.8;
        } else if (b.dragging) {
          aWeight = 0.8; bWeight = 0.2;
        } else {
          aWeight = 0.5; bWeight = 0.5;
        }

        // Towed vehicles are rigid — push the other vehicle fully
        if (a.towedById) { aWeight = 0; bWeight = 1; }
        if (b.towedById) { aWeight = 1; bWeight = 0; }

        a.x -= nx * overlap * aWeight;
        a.y -= ny * overlap * aWeight;
        b.x += nx * overlap * bWeight;
        b.y += ny * overlap * bWeight;
      }
    }
  }
}

var towButtonTarget = null;   // vehicle id showing the wrench button (connect or disconnect)

function updateTowing(dt) {
  var vehicles = gameState.vehicles;

  for (var i = 0; i < vehicles.length; i++) {
    var tow = vehicles[i];
    if (!tow.canTow) continue;

    // If already towing — rope physics: front of towed is pinned to heck of tower
    if (tow.towingId) {
      var towed = vehicles.find(function(v) { return v.id === tow.towingId; });
      if (!towed) { tow.towingId = null; continue; }

      var towCs = getCarSize(tow.sizeMul);
      var towedCs = getCarSize(towed.sizeMul);

      // Anchor point: heck of the tow truck
      var towHeadRad = tow.angle * Math.PI / 180;
      var anchorX = tow.x - Math.cos(towHeadRad) * towCs.h * 0.5;
      var anchorY = tow.y - Math.sin(towHeadRad) * towCs.h * 0.5;

      // Rope physics: gradually turn towed vehicle toward the anchor,
      // then position it at rope distance behind the anchor
      var ropeLen = towedCs.h * 0.3;  // visible rope gap
      var fullLen = towedCs.h * 0.5 + ropeLen;

      // Direction from towed vehicle's current position to anchor = rope pull direction
      var dxToAnchor = anchorX - towed.x;
      var dyToAnchor = anchorY - towed.y;
      var distToAnchor = Math.sqrt(dxToAnchor * dxToAnchor + dyToAnchor * dyToAnchor);

      if (distToAnchor > 1) {
        // Target angle: the direction the rope is pulling
        var targetAngle = Math.atan2(dyToAnchor, dxToAnchor) * 180 / Math.PI;
        var angleDiff = ((targetAngle - towed.angle + 540) % 360) - 180;
        var ropeTurnRate = 120;
        var maxTurn = ropeTurnRate * dt;
        if (angleDiff > maxTurn) angleDiff = maxTurn;
        else if (angleDiff < -maxTurn) angleDiff = -maxTurn;
        towed.angle += angleDiff;
        towed.angle = ((towed.angle % 360) + 360) % 360;
      }

      // Position: place towed vehicle so its front is at the anchor, along its own heading
      var towedHeadRad = towed.angle * Math.PI / 180;
      towed.x = anchorX - Math.cos(towedHeadRad) * fullLen;
      towed.y = anchorY - Math.sin(towedHeadRad) * fullLen;

      towed.vx = tow.vx;
      towed.vy = tow.vy;
      continue;
    }

    // Tow attachment is now handled via the UI tow button (see towButtonTarget)
  }
}

function detachTowed(vehicleId) {
  var vehicles = gameState.vehicles;
  var towed = vehicles.find(function(v) { return v.id === vehicleId; });
  if (!towed || !towed.towedById) return false;
  var tower = vehicles.find(function(v) { return v.id === towed.towedById; });
  if (tower) tower.towingId = null;
  towed.towedById = null;
  towed.vx = 0;
  towed.vy = 0;
  return true;
}

function updateTowButton() {
  towButtonTarget = null;
  var vehicles = gameState.vehicles;
  // Find the active ADAC truck
  var adac = vehicles.find(function(v) { return v.canTow && v.id === gameState.activeVehicleId; });
  if (!adac) return;

  // If already towing, show disconnect button on the towed vehicle
  if (adac.towingId) {
    towButtonTarget = adac.towingId;
    return;
  }

  // Find the closest towable vehicle within range (collision distance + small margin)
  var adacCs = getCarSize(adac.sizeMul);
  var adacR = Math.max(adacCs.w, adacCs.h) * 0.45;
  var bestId = null, bestDist = Infinity;
  for (var i = 0; i < vehicles.length; i++) {
    var other = vehicles[i];
    if (other.id === adac.id) continue;
    if (other.towedById) continue;
    if (other.canTow) continue;
    var otherCs = getCarSize(other.sizeMul);
    var otherR = Math.max(otherCs.w, otherCs.h) * 0.45;
    var attachDist = adacR + otherR + otherR * 0.3; // collision dist + 30% margin
    var dx = other.x - adac.x;
    var dy = other.y - adac.y;
    var dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < attachDist && dist < bestDist) {
      bestDist = dist;
      bestId = other.id;
    }
  }
  towButtonTarget = bestId;
}

function hitTestTowButton(clientX, clientY) {
  if (!towButtonTarget) return null;
  var v = gameState.vehicles.find(function(vv) { return vv.id === towButtonTarget; });
  if (!v) return null;
  var sx = v.x * gameState.scale + gameState.panX;
  var sy = v.y * gameState.scale + gameState.panY;
  var cs = getCarSize(v.sizeMul);
  var btnRadius = Math.max(cs.w, cs.h) * gameState.scale * 0.32;
  btnRadius = Math.max(btnRadius, 20);
  var dx = clientX - sx;
  var dy = clientY - sy;
  if (dx * dx + dy * dy <= btnRadius * btnRadius) return towButtonTarget;
  return null;
}

function cameraFollowActive(dt) {
  if (!gameState.cameraFollowing) return;
  var v = gameState.vehicles.find(function(vv) { return vv.id === gameState.activeVehicleId; });
  if (!v) { gameState.cameraFollowing = false; return; }

  var sx = v.x * gameState.scale + gameState.panX;
  var sy = v.y * gameState.scale + gameState.panY;
  var cw = canvas.width, ch = canvas.height;
  var marginX = cw * 0.3, marginY = ch * 0.3;

  if (sx < marginX || sx > cw - marginX || sy < marginY || sy > ch - marginY) {
    var targetPanX = cw/2 - v.x * gameState.scale;
    var targetPanY = ch/2 - v.y * gameState.scale;
    var ease = Math.min(1, dt * 2.5);
    gameState.panX += (targetPanX - gameState.panX) * ease;
    gameState.panY += (targetPanY - gameState.panY) * ease;
  }

  if (!v.dragging) {
    gameState.cameraFollowing = false;
  }
}

// ============================================================
// INPUT
// ============================================================

var pointers = {};
var touchStartTime = 0;
var touchMoved = false;
var lastPanX = 0, lastPanY = 0;
var lastPinchDist = 0, lastPinchCX = 0, lastPinchCY = 0;
var isPanning = false;
var tapStartX = 0, tapStartY = 0;

// Dragging state
var draggedVehicle = null;   // vehicle being steered
var isDragging = false;       // committed to dragging (past threshold)
var isTouch = false;          // current interaction is touch (not mouse)

function getPointerArray() { return Object.values(pointers); }

function getPinchData(arr) {
  var dx = arr[1].x - arr[0].x, dy = arr[1].y - arr[0].y;
  return { dist: Math.sqrt(dx*dx+dy*dy), cx: (arr[0].x+arr[1].x)/2, cy: (arr[0].y+arr[1].y)/2 };
}

function screenToWorld(sx, sy) {
  return { x: (sx - gameState.panX) / gameState.scale, y: (sy - gameState.panY) / gameState.scale };
}

function getVehicleAtScreen(clientX, clientY, skipTowed) {
  var wp = screenToWorld(clientX, clientY);
  var best = null, bestDist = Infinity;
  for (var i = 0; i < gameState.vehicles.length; i++) {
    var v = gameState.vehicles[i];
    if (skipTowed && v.towedById) continue;
    var cs = getCarSize(v.sizeMul);
    var threshold = Math.max(cs.w, cs.h) * 0.8;
    var dx = wp.x - v.x, dy = wp.y - v.y;
    var dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < threshold && dist < bestDist) { bestDist = dist; best = v; }
  }
  return best;
}

function releaseVehicle() {
  if (draggedVehicle) {
    draggedVehicle.dragging = false;
    draggedVehicle.targetX = null;
    draggedVehicle.targetY = null;
  }
  isDragging = false;
  draggedVehicle = null;
}

function setupInput() {
  var viewport = document.getElementById('game-screen');

  viewport.addEventListener('pointerdown', function(e) {
    if (e.target.closest('.ui-btn')) return;
    e.preventDefault();
    pointers[e.pointerId] = { x: e.clientX, y: e.clientY, type: e.pointerType };
    var pArr = getPointerArray();

    if (pArr.length === 1) {
      touchStartTime = Date.now();
      touchMoved = false;
      lastPanX = e.clientX; lastPanY = e.clientY;
      tapStartX = e.clientX; tapStartY = e.clientY;
      isPanning = false;
      isDragging = false;
      isTouch = e.pointerType === 'touch';

      // Check if finger landed on a vehicle (skip towed vehicles entirely)
      var hitV = getVehicleAtScreen(e.clientX, e.clientY, true);
      // If no vehicle hit but there's an active vehicle, drive that one
      if (!hitV && gameState.activeVehicleId) {
        var activeV = gameState.vehicles.find(function(v) { return v.id === gameState.activeVehicleId; });
        if (activeV && !activeV.towedById) hitV = activeV;
      }
      draggedVehicle = hitV || null;
    } else if (pArr.length >= 2) {
      // Second finger → cancel drag, switch to pinch
      releaseVehicle();
      var pd = getPinchData(pArr);
      lastPinchDist = pd.dist; lastPinchCX = pd.cx; lastPinchCY = pd.cy;
      isPanning = true;
    }
  }, { passive: false });

  viewport.addEventListener('pointermove', function(e) {
    if (!pointers[e.pointerId]) return;
    e.preventDefault();
    pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
    var pArr = getPointerArray();

    if (pArr.length === 1) {
      var dx = e.clientX - lastPanX, dy = e.clientY - lastPanY;
      var totalDx = e.clientX - tapStartX, totalDy = e.clientY - tapStartY;
      var totalDist = Math.sqrt(totalDx * totalDx + totalDy * totalDy);

      // Commit to drag-car or pan-map once past threshold
      // Touch: single finger only drags vehicles, never pans (use two fingers to pan)
      // Mouse: single pointer can drag vehicles or pan the map
      if (!isPanning && !isDragging && totalDist > 10) {
        touchMoved = true;
        if (draggedVehicle) {
          isDragging = true;
          draggedVehicle.dragging = true;
          gameState.activeVehicleId = draggedVehicle.id;
          gameState.cameraFollowing = false;
        } else if (!isTouch) {
          isPanning = true;
          gameState.cameraFollowing = false;
        }
      }

      if (isDragging && draggedVehicle) {
        // Update target — physics runs in game loop
        var wp = screenToWorld(e.clientX, e.clientY);
        draggedVehicle.targetX = Math.max(0, Math.min(worldW, wp.x));
        draggedVehicle.targetY = Math.max(0, Math.min(worldH, wp.y));
        lastPanX = e.clientX; lastPanY = e.clientY;
      } else if (isPanning) {
        gameState.panX += dx; gameState.panY += dy;
        lastPanX = e.clientX; lastPanY = e.clientY;
        gameState.cameraFollowing = false;
      }
    } else if (pArr.length >= 2) {
      var pd = getPinchData(pArr);
      gameState.cameraFollowing = false;
      var zoomRatio = pd.dist / lastPinchDist;
      var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, gameState.scale * zoomRatio));
      var dCx = pd.cx - lastPinchCX, dCy = pd.cy - lastPinchCY;
      gameState.panX = gameState.panX + dCx - (lastPinchCX - gameState.panX) * (newScale / gameState.scale - 1);
      gameState.panY = gameState.panY + dCy - (lastPinchCY - gameState.panY) * (newScale / gameState.scale - 1);
      gameState.scale = newScale;
      lastPinchDist = pd.dist; lastPinchCX = pd.cx; lastPinchCY = pd.cy;
      touchMoved = true;
    }
  }, { passive: false });

  viewport.addEventListener('pointerup', function(e) {
    if (!pointers[e.pointerId]) return;
    e.preventDefault();

    var wasDragging = isDragging;

    // Release car
    if (isDragging) {
      releaseVehicle();
      savePackState(currentPack);
    }

    delete pointers[e.pointerId];
    var elapsed = Date.now() - touchStartTime;

    // Tap: check tow button first, then select/deselect vehicle
    if (!touchMoved && !wasDragging && elapsed < 400) {
      var towBtnHit = hitTestTowButton(tapStartX, tapStartY);
      if (towBtnHit) {
        // Toggle towing
        var adac = gameState.vehicles.find(function(v) { return v.canTow && v.id === gameState.activeVehicleId; });
        if (adac) {
          var target = gameState.vehicles.find(function(v) { return v.id === towBtnHit; });
          if (target && target.towedById) {
            // Disconnect
            detachTowed(target.id);
          } else if (target && adac && !adac.towingId) {
            // Connect
            adac.towingId = target.id;
            target.towedById = adac.id;
            target.dragging = false;
            target.targetX = null;
            target.targetY = null;
          }
        }
        savePackState(currentPack);
      } else {
        var tappedV = getVehicleAtScreen(tapStartX, tapStartY);
        if (tappedV) {
          if (gameState.activeVehicleId === tappedV.id) {
            gameState.activeVehicleId = null;
          } else {
            gameState.activeVehicleId = tappedV.id;
          }
          gameState.cameraFollowing = false;
          savePackState(currentPack);
        }
      }
    }

    isDragging = false;
    draggedVehicle = null;

    var pArr = getPointerArray();
    if (pArr.length >= 2) {
      var pd = getPinchData(pArr);
      lastPinchDist = pd.dist; lastPinchCX = pd.cx; lastPinchCY = pd.cy;
    } else if (pArr.length === 1) {
      var p = pArr[0];
      lastPanX = p.x; lastPanY = p.y;
      isPanning = !isTouch;  // don't pan with remaining touch finger
    }
  }, { passive: false });

  viewport.addEventListener('pointercancel', function(e) {
    releaseVehicle();
    delete pointers[e.pointerId];
  });

  viewport.addEventListener('wheel', function(e) {
    e.preventDefault();
    gameState.cameraFollowing = false;
    var zoomFactor = e.deltaY < 0 ? 1.08 : 0.92;
    var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, gameState.scale * zoomFactor));
    gameState.panX = e.clientX - (e.clientX - gameState.panX) * (newScale / gameState.scale);
    gameState.panY = e.clientY - (e.clientY - gameState.panY) * (newScale / gameState.scale);
    gameState.scale = newScale;
  }, { passive: false });

  // Prevent browser zoom/scroll (but allow taps on UI buttons and world cards)
  document.addEventListener('touchstart', function(e) {
    if (!e.target.closest('.ui-btn') && !e.target.closest('.world-card') && !e.target.closest('#start-screen')) e.preventDefault();
  }, { passive: false });
  document.addEventListener('touchmove', function(e) {
    if (currentScreen !== 'start') e.preventDefault();
  }, { passive: false });
  document.addEventListener('gesturestart', function(e) { e.preventDefault(); });
}

// ============================================================
// UI
// ============================================================

function setupUI() {
  document.getElementById('btn-back').addEventListener('click', function(e) {
    e.stopPropagation();
    savePackState(currentPack);
    currentPack = null;
    packSprites = {};
    worldImage = null;
    history.replaceState(null, '', location.pathname);
    showStartScreen();
  });

  document.getElementById('btn-daynight').addEventListener('click', function(e) {
    e.stopPropagation();
    gameState.isNight = !gameState.isNight;
    applyNightMode();
    savePackState(currentPack);
  });
}

function applyNightMode() {
  // Night darkness is rendered on the canvas (drawNightOverlay) — disable CSS overlay
  document.getElementById('night-overlay').classList.remove('active');
  var btn = document.getElementById('btn-daynight');
  btn.innerHTML = gameState.isNight ? '&#x1F319;' : '&#x2600;';
}

// ============================================================
// SCREENS
// ============================================================

function showStartScreen() {
  currentScreen = 'start';
  document.getElementById('start-screen').classList.remove('hidden');
  document.getElementById('game-screen').classList.remove('active');
}

function showGameScreen() {
  currentScreen = 'game';
  document.getElementById('start-screen').classList.add('hidden');
  document.getElementById('game-screen').classList.add('active');
  resizeCanvas();
}

function buildStartScreen() {
  var list = document.getElementById('world-list');
  list.innerHTML = '';

  for (var i = 0; i < ASSET_PACKS.length; i++) {
    (function(pack) {
      var card = document.createElement('div');
      card.className = 'world-card';

      var thumb = document.createElement('div');
      thumb.className = 'world-card-thumb';
      var thumbCanvas = document.createElement('canvas');
      thumbCanvas.width = 260; thumbCanvas.height = 195;
      var tctx = thumbCanvas.getContext('2d');

      // Load actual world image as thumbnail
      var thumbImg = new Image();
      thumbImg.onload = function() { tctx.drawImage(thumbImg, 0, 0, 260, 195); };
      thumbImg.onerror = function() {
        var placeholder = generatePlaceholderWorld(WORLD_W, WORLD_H);
        tctx.drawImage(placeholder, 0, 0, 260, 195);
      };
      thumbImg.src = pack.worldImage;
      thumb.appendChild(thumbCanvas);

      var name = document.createElement('div');
      name.className = 'world-card-name';
      name.textContent = pack.name;

      card.appendChild(thumb);
      card.appendChild(name);
      card.addEventListener('click', function() { startPack(pack); });
      list.appendChild(card);
    })(ASSET_PACKS[i]);
  }
}

function startPack(pack) {
  currentPack = pack;
  history.replaceState(null, '', '#' + pack.id);

  Promise.all([
    loadWorldImage(pack),
    loadPackSprites(pack),
  ]).then(function() {
    initVehicles(pack);
    var loaded = loadPackState(pack);

    if (!loaded) {
      var vw = window.innerWidth, vh = window.innerHeight;
      gameState.scale = Math.min(vw / worldW, vh / worldH) * 1.5;
      gameState.panX = (vw - worldW * gameState.scale) / 2;
      gameState.panY = (vh - worldH * gameState.scale) / 2;
    }

    applyNightMode();
    showGameScreen();
  });
}

// ============================================================
// GAME LOOP
// ============================================================

var lastTime = 0;

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  var dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  gameState.pulseTime += dt;

  if (currentScreen === 'game') {
    updateVehicles(dt);
    updateTowButton();
    cameraFollowActive(dt);
    render();
  }

  requestAnimationFrame(gameLoop);
}

// ============================================================
// INIT
// ============================================================

function init() {
  migrateV5Storage();
  buildStartScreen();
  setupInput();
  setupUI();
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  setInterval(function() { if (currentPack) savePackState(currentPack); }, 5000);
  document.addEventListener('visibilitychange', function() {
    if (document.hidden && currentPack) savePackState(currentPack);
  });

  // Deep-link: #city jumps straight into the world
  var hash = location.hash.replace('#', '');
  if (hash) {
    var pack = ASSET_PACKS.find(function(p) { return p.id === hash; });
    if (pack) { startPack(pack); }
  }

  lastTime = 0;
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
